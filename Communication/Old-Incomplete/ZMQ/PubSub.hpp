
#ifndef THERON_ZERO_MESSAGE_QUEUE
#define THERON_ZERO_MESSAGE_QUEUE

#include <string>							// Standard strings
#include <sstream>						// Stream operators on strings
#include <map>								// Storing sockets for remote endpoints.
#include <unordered_map>			// Last good value cache for data publishers
#include <list>               // For temporary storing subscription requests
#include <memory>             // Shared pointers
#include <typeinfo>						// For published message types
#include <typeindex>          // To store typeIDs in containers
#include <type_traits>        // For useful meta programming

#include <zmqpp.hpp>					// ZeroMQ bindings for C++

#include "Actor.hpp"					                  // The Theron++ actor framework
#include "Communication/NetworkEndpoint.hpp"    // Host for the endpoint servers
#include "Communication/LinkMessage.hpp"		    // Link message interface
#include "Communication/NetworkLayer.hpp"       // The network layer interface
#include "Utility/StandardFallbackHandler.hpp"  // Catching unhanded messages
#include "Communication/SerialMessage.hpp"      // Serial network messages
#include "Communication/DeserializingActor.hpp" // Receiving serial messages

#include "Communication/ZMQ/ZMQMessages.hpp"    // Message format

namespace Theron::ZeroMQ
{
/*==============================================================================

 Publishing

==============================================================================*/
//
// There are two sources for published data:
//
// 1. The data can be generated by an actor on the remote actor system
//    endpoint. In this case the data will be encoded by the session layer
//    as a "Data" type outside message.
// 2. The data is published by some other system and is received just as a
//    string.
//
// In both cases the issue is at the receiving side since a subscriber socket
// does not tell where the data is coming from. Which is natural since it is
// implementing a pure publish-subscribe pattern where the data source is
// known from the subscription. It is allowed that the publisher has many
// subscribers.
//
// A subscription has a "topic" and a subscriber can subscribe to different
// topics from different providers. However, the subscriber socket will not
// tell us to which topic an incoming message belongs.
//
// Finally, there is the Last Value Caching (LVC) issue: If a subscriber
// to an infrequently updated value subscribes shortly after the last value
// was published, then it can take a long time before the subscriber receives
// the next value, and this could potentially cause problems.
//
// The ideal situation would be that each publishing actor has its own PUB
// socket. This would necessitate a separate IP port for each actor, and this
// cannot be done in a generic way. Hence the only option is that each endpoint
// has one data publisher socket implemented as an XPUB socket. This is
// configured to use the ZMQ_XPUB_VERBOSE so that the handler function is called
// every time an actor subscribes to a given topic. The handler function will
// then retransmit the last good value cached for this topic. Unfortunately,
// both the XPUB and the ZMQ_XPUB_VERBOSE are poorly documented. The ZMQ
// Requests For Comments (RFC) give some basic behaviour [15], and the best
// example is Pieter Hintjens example of a publisher that awaits a known number
// of subscriptions to connect before it starts to publish [16]
//
// The downside of this is that all subscribers will get the cached value when
// new subscribers arrive. This could be undesirable if the arrival of a new
// topic value triggers other activities by the receiving actor. The subscriber
// should therefore check for identity updates and only forward the update to
// the actor if the value is different from the current value.
//
// -----------------------------------------------------------------------------
// Publishing link
// -----------------------------------------------------------------------------
//
// The main purpose of the class is to manage a socket for publishing the data.
// One could imagine that the publishing link would also maintain a Last Good
// Value cache. A deep and philosophical observation should be noted: under a
// publish-subscribe pattern the publisher will not know when other actors in
// the system subscribe - or unsubscribe. Thus, it is possible to subscribe to
// a topic with no publisher and receive silence, and it is possible to publish
// on a topic with no subscribers. For this reason the publishing link is never
// able to clear the cache of the last good value from a publisher because
// even if the publisher does no longer exist (or we do not know when it will
// publish next), there may be subscribers wanting the last good value.
// Furthermore, even if we know that there are no more subscribers to a topic,
// it does not preclude future subscribers from arriving.
//
// Given that a managed topic corresponds to a message type, the number of
// message types supported by an actor does not grow wildly. If there are
// many different actor types in use the total number of topics will, at most,
// be the product of the number of actor instances of an actor type,
// times the the number of messages it supports, and this factor should be
// added for all actor types. Hence the worst case can be difficult, and
// if the payload size of the messages is large, it could be a significant
// amount of data to keep in memory.
//
// One approach could be to use a "garbage collection" type technique building
// on reference counting: When a topic is no longer subscribed to, it is a
// candidate for cache deletion. Then two approaches would be possible:
//
// 1. Delete the last good value for the topic when the total number of
//    topics, or the cache size in bytes, reaches a threshold or watermark.
//    In this case the topics with the largest payloads could be deleted
//    first.
// 2. Record when the topic is published. If a topic has no subscribers and
//    there time since last publication is longer than a certain time out
//    limit, the topic should be deleted.
//
// The first is a size based strategy whereas the second is a time out
// strategy. Both of these can alleviate the problem, but none is perfect.
//
// A truly different approach is needed based on the observation that if a
// publishing agent is gone, there is no need to cache its topics! This holds
// irrespective of the number of subscribers for this topic. This implies
// that the actor should cache its own last good value, and re-publish this
// when its topic has a new subscriber. A further benefit is that the binary
// message can be cached since it will typically take less space than its
// serialised counterpart. Consider for example a boolean that essentially
// requires one binary bit, or five characters "true" or "false" or 8 bits if
// represented as a character 0 or 1.
//
// This approach is implemented in a base class "Publisher" offering one
// method publish a message accessible for derived classes, and which runs
// a protocol with the publishing link in the background:
//
// A. Published messages are serialised and sent as a message to the link
//    actor.
// B. The link actor sends a new subscriber message back to the actor when
//    the actor has a new subscriber to one of its topics. When the actor
//    gets this message, it will look up the last value for the topic and
//    re-publish the last value.
// C. When the actor closes, its destructor will send a delete topic
//    message that will remove all references to its topics.

class PublishingLink : virtual public Actor,
											 virtual public StandardFallbackHandler,
											 public Link
{

private:

	zmqpp::socket DataPublisher;
	std::unordered_map< std::string, Address > Publishers;

	// The topic string is defined similar to a Jabber ID of the form
	// "actorname@endpoint/messageID" since an actor may publish several
	// different message types.

	inline static std::string SetTopic( const std::string & ActorName,
																		  const std::string & EndpointID,
																		  const std::string & MessageID )
	{
		return ActorName + "@" + EndpointID + "/" + MessageID;
	}

	// Then there are various interfaces to this string version. First one where
	// the actor the actor and topic is given and the local endpoint is assumed
	// by default

	template< class MessageType >
	static std::string SetTopic( const Address & TheActor )
	{
		std::string EndpointID( GetNetworkAddress().GetIP().to_string() ),
		            MessageID( typeid( MessageType ).name() );

		return SetTopic( TheActor.AsString(), EndpointID, MessageID );
	}

	// Another version takes both the actor and the endpoint as objects and then
	// does the full conversion

	template< class MessageType >
	static std::string SetTopic( const Address & TheActor,
															 NetworkAddress TheEndpoint )
	{
		return SetTopic( TheActor.AsString(), TheEndpoint.GetIP().to_string(),
										 typeid( MessageType ).name() );
	}

  // ---------------------------------------------------------------------------
  // Supporting subscribers
  // ---------------------------------------------------------------------------
	//
  // A subscribing actor will need to create the subscriber socket in the same
  // context as the other sockets, and it therefore needs access to the
  // context and the socket monitor.

  using Link::GetContext;
	using Link::GetMonitor;

	// In order to access these the subscriber class is declared as a friend

  friend class Subscriber;

	// When a topic subscription arrives, it will be checked against the registry
	// of publishers, and if the topic is known a message is sent to the owning
	// actor to re-publish the cached last good value. The message simply contains
	// the topic string.

	class SendLastGoodValue
	{
	public:

		const std::string Topic;

		SendLastGoodValue( const std::string & GivenTopic )
		: Topic( GivenTopic )
		{ }

		SendLastGoodValue( const SendLastGoodValue & Other )
		: Topic( Other.Topic )
		{ }

		SendLastGoodValue( const SendLastGoodValue && Other )
		: Topic( Other.Topic )
		{ }

		SendLastGoodValue( void ) = delete;
	};

	// There is a handler called when there is a subscription event on the
	// publisher socket, and this will send the message to the actor if there
	// is already a publisher for this topic. Otherwise, it will do nothing.

	void SubscriptionEvents( void );

  // ---------------------------------------------------------------------------
  // Publishing a message
  // ---------------------------------------------------------------------------
	//
	// The publisher actor base class has to be a friend of this link in order to
	// engage in the last good value cache protocol outlined.

	friend class Publisher;

	// When an actor wants to publish a message it will implicitly send a message
	// to this link actor containing the topic for which the message is published
	// and the serialised message content. The message structure is simple

	class PublishableMessage
	{
	public:

		const std::string Topic;
		const SerialMessage::Payload Payload;

		template< class MessageType >
		PublishableMessage( const MessageType & TheMessage,
												const std::string & ActorName )
		: Topic( SetTopic< MessageType >( ActorName ) ),
		  Payload( TheMessage->Serialize() )
		{ }

		// When this is used to publish a message from the last good value cache,
		// the topic is already given, and there is a pointer to the Serial Message
		// to be sent. In this case the constructor takes a different form.

		PublishableMessage( const std::string & TheTopic,
												std::shared_ptr< SerialMessage > & TheMessage )
		: Topic( TheTopic ), Payload( TheMessage->Serialize() )
		{ }

		// Then there are trivial copy and move constructors.

		PublishableMessage( const PublishableMessage & Other )
		: Topic( Other.Topic ), Payload( Other.Payload )
		{ }

		PublishableMessage( const PublishableMessage && Other )
		: Topic( Other.Topic ), Payload( Other.Payload )
		{ }

		PublishableMessage( void ) = delete;
	};

	// This is served by a message handler that stores the new payload for this
	// topic before forwarding the message to the publisher socket.

	void DispatchMessage( const PublishableMessage & TheMessage,
												const Address ThePublisher );

  // ---------------------------------------------------------------------------
  // Closing a publisher
  // ---------------------------------------------------------------------------
	//
	// When a publisher actor closes, its destructor will send a message to
	// indicate this to the link. It is the message type that carries the command.

	class ClosePublisher
	{
	public:

		ClosePublisher( void ) = default;
		ClosePublisher( const ClosePublisher & Other ) = default;
	};

	// The message handler for this will simply look up what topics has the
	// sender actor as publisher, and erase these.

	void DeletePublisher( const ClosePublisher & TheCommand,
												const Address ThePublisher );

  // ---------------------------------------------------------------------------
  // Constructor and destructor
  // ---------------------------------------------------------------------------
	//
  // The constructor takes the same parameters as the basic link server, and
  // sets up the data publisher and binds it to the right port.

public:

  PublishingLink( const IPAddress & InitialRemoteEndpoint,
							    const std::string & RemoteLinkServerName = "ZMQLink",
							    const std::string & ServerName = "ZMQLink" );

	virtual ~PublishingLink( void )
	{ }
};

// -----------------------------------------------------------------------------
// Publisher
// -----------------------------------------------------------------------------
//

class Publisher : virtual public Actor,
								  virtual public StandardFallbackHandler
{
private:

	// The last good value is a map from the topic value to a Serial Message
	// pointer since the Serial Message is the base class of all messages that
	// can be published. A shared pointer is used to ensure that the message
	// copy it points to will be deleted on reassignment, or when the map is
	// deleted by the class destructor.

	std::unordered_map< std::string,
										  std::shared_ptr< SerialMessage > > LastGoodValue;

	// There is a handler for new subscriptions sent from the publishing link

	void NewSubscription( const PublishingLink::SendLastGoodValue & Broadcast,
												const Address TheLink	);

	// The actor will simply call the publish function to send a message to all
	// its subscribers. This will send the message to the publishing link and
	// cache a copy of the message as the last good value for this topic.

protected:

	template< class MessageType >
	void Publish( const MessageType & TheMessage )
	{
		// All messages should be serial messages and copyable

		static_assert( std::is_base_of< SerialMessage, MessageType >::value,
			"The message to be published must be derived from the Serial Message"	);

		static_assert( std::is_copy_constructible< MessageType >::value,
			"The message must be copy constructable"	);

		// The publishable message is created as it will provide the topic, and
		// then sent to the publishing link to be transmitted to the outside.

		PublishingLink::PublishableMessage BroadcastMessage(
																			 TheMessage, GetAddress().AsString() );

		Send( BroadcastMessage, Network::GetAddress( Network::Layer::Network ) );

		// Then the binary message can be stored as a copy in the Last Good Value
		// cache

		LastGoodValue[ BroadcastMessage.Topic ] =
																	std::make_shared< MessageType >( TheMessage );
	}

	// The constructor is protected to ensure that a publisher actor is not
	// created stand-alone but only as a base class of a real actor using this
	// interface.

	Publisher( const std::string Name = std::string() );

	virtual ~Publisher( void );
};

/*==============================================================================

 Subscribing

==============================================================================*/
//
// The subscriber actor is a utility base class for an actor that wants to
// subscribe to events published by other actors. It provides a subscription
// socket for receiving the data, and it connects to the data publishers on
// the endpoints hosting the actors subscribed to.
//
// The class maintains a cache of the last received message type for each topic,
// and if the received value is identical to the one already cached, it is
// simply ignored. It should be noted that since the message format is encoded
// in the topic string (see the publishing link above), an actor can subscribe
// to many different message formats from the same publishing actor. The only
// requirement is that the same message format cannot be used by two different
// data streams from the same actor.
//
// Since the messages are serialised it is mandatory that the message formats
// used are derived from the Serial Message, and the subscriber actor has to
// be a Deserializing actor in order to correctly convert the various serial
// messages it receives.

class Subscriber : virtual public Actor,
									 virtual public StandardFallbackHandler,
									 virtual public DeserializingActor
{
private:

	// The socket taking care of the subscription

	zmqpp::socket Subscription;

	// The subscribed topic must be unique, and in order to disconnect from the
	// remote TCP endpoint when the last topic published by that endpoint is
	// unsubscribed, the network address of the topic must be remembered. It is
	// a philosophical question how to treat repeated updates with the same
	// value on a topic. They could be seen as some kind of heartbeat signals
	// that should be handled by the actor. However, they will be filtered out
	// in this implementation since it is taken that the actual value is
	// important and carries the information and not the arrival event.
	// A heartbeat protocol must therefore ensure that the valued published must
	// be different from the last value (but it is OK to oscillate between two
	// values). In order to do the value filtering the last received value, i.e.
	// the message payload, be stored.

	class TopicInformation
	{
	public:

		const NetworkAddress   Connection;
		SerialMessage::Payload LastReceivedValue;

		TopicInformation( const TCPAddress & TCPEndpoint,
										  const std::string & ActorName = std::string() )
		: Connection( TCPEndpoint, ActorName ), LastReceivedValue()
		{ }

		TopicInformation( void ) = delete;
	};

	// The topics and the related information class are kept in an unordered map

	std::unordered_map< std::string, TopicInformation > ActiveSubscriptions;

  // ---------------------------------------------------------------------------
  // Subscription handler
  // ---------------------------------------------------------------------------
	//
	// When the subscription socket has a message the socket monitor will call
	// the handler for subscriptions

	void SubscriptionHandler( void );

  // ---------------------------------------------------------------------------
  // Subscribing and address resolution
  // ---------------------------------------------------------------------------
	//
  // To be able to connect the subscriber to the publisher, the publisher
	// endpoint address must be known. The principle of transparent communication
	// implies that an actor only needs to know the actor name of the remote actor
	// and not its location. It is the role of the session layer server to keep
	// track of where agents are located, and the subscriber must use the address
	// resolution protocol to find the endpoint address of the actor.
	//
	// This implies that the subscriber must send a message to the network layer
	// server and then wait for the response to come back as a separate message
	// before the actual connection to the publisher socket can be made. During
	// this interval, the actor can initiate subscriptions for other publishers,
	// and so it is important to cache the subscription requests and fulfil them
	// once the corresponding endpoints become known.

	std::multimap< Address, std::type_index > PendingRequests;

	// There is a message handler that will receive the resolved address from
	// the session layer server and then set the topic and subscribe. The pending
	// request is deleted after connecting the socket to the publisher for the
	// actor.

  void ConnectSubscription( const Link::ResolutionResponse & ResolvedAddress,
														const Address SessionLayerServer );

	// The main method for the actor itself is the subscribe method that stores
	// the request as pending, and asks the network layer server to resolve the
	// actor's external address. Note that this must be called with template
	// syntax making the message type explicit.

protected:

	template< class MessageType >
	void Subscribe( const Address & PublishingActor )
	{
		static_assert( std::is_base_of< SerialMessage, MessageType >::value,
			"It is only possible to subscribe to messages derived from Serial Message"
		);

		PendingRequests.emplace( PublishingActor, typeid( MessageType ) );

		Send( Link::ResolutionRequest( PublishingActor ),
					Network::GetAddress( Network::Layer::Network ) );
	}

	// The second version of this function assumes that both the topic and the
	// network endpoint is known. A message type must still be given to verify
	// that the received payload will be de-serialised by a message, and the
	// message will be sent with "this" actor as sender (sending-to-self) since
	// the remote publisher may not even be an actor. For the same reason, this
	// topic will not be registered in the map of received values, since the
	// actual notification could be a heartbeat from the remote publisher. It
	// should be noted in passing that the time interval between two heartbeats
	// cannot be taken as a constant.

	template< class MessageType >
	void Subscribe( const std::string & Topic, const TCPAddress & Location,
									const std::string & PublishingActorName = std::string() )
	{
		static_assert( std::is_base_of< SerialMessage, MessageType >::value,
			"A Serial Message must receive the serialised payload subscribed to"
		);

		// The topic is inserted into the list of active connections, and
		// connected if the topic is unique.

		auto Result = ActiveSubscriptions.emplace( Topic, Location,
																							 PublishingActorName );

		if ( Result.second == true )
		{
			// It is assumed that it will not harm if a second connection for the same
			// TCP endpoint is made. This could happen if a one subscribes to a
			// different topic for the same endpoint.

			Subscription.connect( Location.AsString() );
			Subscription.subscribe( Topic );
		}
		else
		{
			std::ostringstream ErrorMessage;

			ErrorMessage << "Subscription topic \"" << Topic << "\" does already "
									 << "exists for actor " << GetAddress().AsString();

		  throw std::invalid_argument( ErrorMessage.str() );
		}
	}

	// It is also possible to unsubscribe from a subscription. In this case
	// the message type has no meaning, but is required for aligning the syntax
	// of the functions. If there are no active topics for the given endpoint,
	// then the subscription socket will be disconnected from the endpoint.

  template< class MessageType >
  void Unsubscribe( const std::string & Topic )
	{
		// First a sanity check to see if there is a connection to unsubcribe from

		auto CurrentSubscription = ActiveSubscriptions.find( Topic );

		if ( CurrentSubscription != ActiveSubscriptions.end() )
		{
			Subscription.unsubscribe( Topic );

			// Then all connections must be checked to see if there are other
			// connections sharing the same TCP endpoint. The current subscription
			// will anyway be removed, but its network address should be cached
			// before removal.

			std::string PublisherAddress =
									CurrentSubscription->second.Connection.GetEndpoint();

			ActiveSubscriptions.erase( CurrentSubscription );

			// Now the current subscription iterator can be used to check if there
			// are other connections to the same remote endpoint

			for ( CurrentSubscription = ActiveSubscriptions.begin();
					  CurrentSubscription != ActiveSubscriptions.end();
						++CurrentSubscription )
			  if( PublisherAddress ==
					  CurrentSubscription->second.Connection.GetEndpoint() )
					return;

			// Arriving at this point means that this was the only connection to
			// this TCP endpoint and it will be disconnected

			Subscription.disconnect( PublisherAddress );
		}
	}

	// It is also possible to unsubscribe from a topic. The format of the method
	// is the same, but the action is immediate. This means that the topic string
	// must be parsed: It is necessary to find the actor publishing and then the
	// message type being published. If both matches, it is possible to
	// unsubscribe and forget about the topic. Since the filtering happens at
	// the publisher side since ZMQ 3.0 it is safe to assume that the socket
	// communicates the removed topic to all connected publishers and the one
	// serving this topic notifies that this endpoint will no longer receive
	// updates.

	template< class MessageType >
	void Unsubscribe( const Address & PublishingActor )
	{
		// It is not strictly necessary here to ensure that the message is a serial
		// message, but it adds to the compile time checking of possible mistakes

		static_assert( std::is_base_of< SerialMessage, MessageType >::value,
			"Only Serial Messages can be subscribed to"	);

		// Since this is a managed subscription, the format of the topic string
		// is given and the topic based unsubcribe function can be used.

		Unsubscribe< MessageType >(
				PublishingLink::SetTopic< MessageType >( PublishingActor.AsString() ) );
	}

  // ---------------------------------------------------------------------------
  // Constructor
  // ---------------------------------------------------------------------------
	//
	// The constructor optionally takes a name for the actor. It should be noted
	// that this constructor is protected (on purpose) to ensure that no free
	// subscriber object is instantiated. It must be used by a proper actor that
	// knows how to handle the payload content of the received events.

	Subscriber( const std::string & name = std::string() );

	// The virtual destructor unsubscribes from all active connections and
	// disconnect from all remote endpoints before the monitor is requested to
	// stop monitoring this socket.

public:

	virtual ~Subscriber( void );
};

}					// name space Theron::ZeroMQ
#endif 		// THERON_ZERO_MESSAGE_QUEUE
