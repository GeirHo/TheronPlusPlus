/*==============================================================================
Active Message Queue (AMQ) JSON messages

The JavaScript Object Notation (JSON) is a much used standard for information 
exchange supporting simple values, recursive key-value maps and arrays [1]. 
The same structure is provided by Qpid Proton AMQ interface [2]. Thus, the 
standard way of communication JSON structures over the network is to searialise 
the message to a simple string and the recreate the JSON structure at the 
receiver parsing the syntax of the received string.

However, given that the Qpid Proton AMQ interface mirrors the data types of 
JSON, the purpose of this class is to create an AMQ message from the JSON 
structure, and then leave the potential serialisation to the Network Layer. 
For this the Niels Lohmann's JSON library will be used as it is written 
with a modern C++ interface, and an interface simlar Standard Template 
library (STL) [2].

References: 
[1] https://www.iso.org/standard/71616.html
[2] https://github.com/nlohmann/json

Author and Copyright: Geir Horn, University of Oslo
Contact: Geir.Horn@mn.uio.no
License: LGPL 3.0 (https://www.gnu.org/licenses/lgpl-3.0.en.html)
==============================================================================*/

#ifndef THERON_AMQ_JSON_MESSAGE
#define THERON_AMQ_JSON_MESSAGE

// Standard headers


// Niels Lohmann's JSON library

#include <nlohmann/json.hpp>
using JSON = nlohmann::json;

// The Qpid Proton headers

#include "proton/message.hpp"
#include "proton/map.hpp"

// The Theron++ messages

#include "Communication/PolymorphicMessage.hpp"
#include "Communication/AMQ/AMQMessage.hpp"

namespace Theron::AMQ
{

class JSONMessage
: virtual public Theron::PolymorphicMessage<
                 typename Theron::AMQ::Message::PayloadType >,
  public JSON
{
 public:

    using ProtocolPayload = PolymorphicMessage< 
          typename Theron::AMQ::Message::PayloadType >::PayloadType;

  // JSON messages must have a unique message identifier string. This will be
  // embedded in the message content type so that the message can be correctly
  // decoded by the receiver. The issue is that when the AMQ message is 
  // unpacked to a JSON message, one will end up with an attribute-value
  // map for all messages, but and one will need to test all the attributes 
  // to see if the JSON message structure is as expected. However, having 
  // the unique identifier available, this can be tested in the overloaded 
  // initialisation function to validate that the message is as expeced by 
  // a derived JSON message type.

private:

  const std::string UniqueMessageIdentifier;

  // There is a read-only function to allow derived classes to introspect
  // and check the message identifier.

protected:

  inline const std::string & GetMessageIdentifier( void ) const
  { return UniqueMessageIdentifier; }

  // Taking full adavantage of the structured AMQ message implies that the 
  // JSON structure itself is represented as a map from strings to AMQ values, 
  // where value can again be an object owing to the recursive nature of the 
  // JSON stricture. It is therefore a dedicated function to convert a
  // JSON value to a AMQ Proton value.

private:

  proton::value Json2AMQValue( const JSON & TheValue ) const;

  // In the same way, the AMQ message can also be structured, and each value
  // must be correctly decoded to a proper JSON value. 
  
  JSON AMQValue2Json( const proton::value & TheValue ) const;

protected:

  virtual ProtocolPayload GetPayload( void ) const override;
  virtual bool 
  Initialize( const ProtocolPayload & ThePayload ) noexcept override;

public:

  // The constructor requires the unique message identifier to recognise 
  // the incoming message types by the content type field set.

  JSONMessage( const std::string & TheMessageID )
  : JSON(), UniqueMessageIdentifier( TheMessageID )
  {}

  // The default constructor is not allowed 

  JSONMessage() = delete;
  
  // The copy constructor just copies the content to the JSON  base class and
  // copies the message identifier string,

  JSONMessage( const JSONMessage & Other )
  : JSON( Other ), UniqueMessageIdentifier( Other.UniqueMessageIdentifier )
  {}

  // Since the JSON object accepts being initialised, there is a constructor
  // to forward the initialiser type. 

  JSONMessage( const std::string & TheMessageID, 
               const JSON::object_t & JSONData )
  : JSON( JSONData ), UniqueMessageIdentifier( TheMessageID )
  {}

  // The destructor is just auto generated by the compiler.

  virtual ~JSONMessage() = default;
};

}      // end namespace Theron::AMQ
#endif // THERON_AMQ_JSON_MESSAGE